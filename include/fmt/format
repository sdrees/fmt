// Formatting library for C++ - the standard API
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_FORMAT_
#define FMT_FORMAT_

#include "core.h"

#define FMT_REQUIRES(...)
#define FMT_CONCEPT(C) typename

namespace std {
template <class O>
  using iter_difference_t = ptrdiff_t;
}

namespace std {
  // [format.error], class format_error
  class format_error;

  // [format.formatter], formatter
  template<class charT> class basic_format_parse_context;
  using format_parse_context = basic_format_parse_context<char>;
  using wformat_parse_context = basic_format_parse_context<wchar_t>;

  template<class O, class charT> FMT_REQUIRES(OutputIterator<O, const charT&>)
    class basic_format_context;
  using format_context = basic_format_context<
    /* unspecified */ std::back_insert_iterator<fmt::internal::basic_buffer<char>>,
    char>;
  using wformat_context = basic_format_context<
    /* unspecified */ std::back_insert_iterator<fmt::internal::basic_buffer<wchar_t>>,
    wchar_t>;

  template<class T, class charT = char> struct formatter;

  // [format.arguments], arguments
  template<class Context> class basic_format_arg;

  template<class Visitor, class Context>
    /* see below */ auto visit_format_arg(Visitor&& vis, basic_format_arg<Context> arg);

  template<class Context, class... Args> struct format_arg_store; // exposition only

  template<class Context> class basic_format_args;
  using format_args = basic_format_args<format_context>;
  using wformat_args = basic_format_args<wformat_context>;

  template<class O, class charT>
    using format_args_t = basic_format_args<basic_format_context<O, charT>>;

  template<class Context = format_context, class... Args>
    format_arg_store<Context, Args...>
      make_format_args(const Args&... args);
  template<class... Args>
    format_arg_store<wformat_context, Args...>
      make_wformat_args(const Args&... args);

  // [format.functions], formatting functions
  template<class... Args>
    string format(string_view fmt, const Args&... args);
  template<class... Args>
    wstring format(wstring_view fmt, const Args&... args);

  string vformat(string_view fmt, format_args args);
  wstring vformat(wstring_view fmt, wformat_args args);

  template<FMT_CONCEPT(OutputIterator<const char&>) O, class... Args>
    O format_to(O out, string_view fmt, const Args&... args);
  template<FMT_CONCEPT(OutputIterator<const wchar_t&>) O, class... Args>
    O format_to(O out, wstring_view fmt, const Args&... args);

  template<FMT_CONCEPT(OutputIterator<const char&>) O>
    O vformat_to(O out, string_view fmt, format_args_t<O, char> args);
  template<FMT_CONCEPT(OutputIterator<const wchar_t&>) O>
    O vformat_to(O out, wstring_view fmt, format_args_t<O, wchar_t> args);

  template<class O>
    struct format_to_n_result {
      O out;
      iter_difference_t<O> size;
    };

  template<FMT_CONCEPT(OutputIterator<const char&>) O, class... Args>
    format_to_n_result<O> format_to_n(O out, iter_difference_t<O> n,
                                      string_view fmt, const Args&... args);
  template<FMT_CONCEPT(OutputIterator<const wchar_t&>) O, class... Args>
    format_to_n_result<O> format_to_n(O out, iter_difference_t<O> n,
                                      wstring_view fmt, const Args&... args);

  template<class... Args>
    size_t formatted_size(string_view fmt, const Args&... args);
  template<class... Args>
    size_t formatted_size(wstring_view fmt, const Args&... args);
}

#endif  // FMT_FORMAT_
